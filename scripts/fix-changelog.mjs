// @ts-check

/**
 * Make the following fixes to `CHANGELOG.md` generated by `release-please-action@v2`:
 *
 * + Insert the "Commits" section
 * + Fix the heading levels
 *
 * Usage: node scripts/fix-changelog.mjs ./path/to/package-root
 */

import { promises as fsAsync } from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import util from 'node:util';

import { awaitMainFn } from '@sounisi5011/cli-utils-top-level-await';

/**
 * @see https://semver.org/#backusnaur-form-grammar-for-valid-semver-versions
 */
const SEMVER_REGEXP = /[0-9]+(?:\.[0-9]+){2}(?:-[.0-9a-zA-Z-]+)?(?:\+[.0-9a-zA-Z-]+)?/;
const VERSION_HEADING_REGEXP = new RegExp(
  String.raw
    `\n+^(?<heading_level>###?) *(?<heading_text>(?:<(\w+)[^>]*>)?(?:(?<version1>${SEMVER_REGEXP.source})|\[(?<version2>${SEMVER_REGEXP.source})\]\([^)]+\)) \([0-9]{4,}(?:-[0-9]{1,2}){2}\)(?:</\3>)?)$`,
  'gm',
);

/**
 * @param {*} value
 * @param {NodeJS.WriteStream | null} targetStream
 * @return {string}
 */
function inspect(value, targetStream = null) {
  /**
   * @see https://github.com/nodejs/node/blob/v18.4.0/lib/internal/console/constructor.js#L317-L319
   */
  const isColorEnabled = Boolean(
    targetStream
      && targetStream.isTTY
      && (typeof targetStream.getColorDepth === 'function' ? targetStream.getColorDepth() > 2 : true),
  );
  return util.inspect(value, { colors: isColorEnabled });
}

/**
 * @typedef {Object} ReplaceInfo
 * @property {number} start
 * @property {number} end
 * @property {string} str
 *
 * @param {string} input
 * @param {readonly ReplaceInfo[]} replaceList
 * @return {string}
 */
function replaceMulti(input, replaceList) {
  if (replaceList.length < 1) return input;

  const sortedReplaceList = [...replaceList].sort((a, b) => {
    if (a.start < b.start) return -1;
    if (b.start < a.start) return +1;

    if (a.end < b.end) return +1;
    if (b.end < a.end) return -1;

    return 0;
  });

  return [
    input.substring(0, sortedReplaceList[0].start ?? 0),
    ...sortedReplaceList.flatMap(({ end, str }, index, list) => {
      const next = list[index + 1];
      return [
        str,
        input.substring(end, next?.start ?? Infinity),
      ];
    }),
  ].join('');
}

/**
 * @param {RegExpMatchArray} headingMatch
 * @param {{ start: number, end: number }} sectionRange
 * @return {Promise<ReplaceInfo>}
 */
async function fixChangelogSection(headingMatch, sectionRange) {
  const changelogText = headingMatch.input ?? '';
  const headingLine = headingMatch[0];
  const sectionBody = changelogText.substring(sectionRange.start + headingLine.length, sectionRange.end);
  const releaseVersion = headingMatch.groups?.version2 ?? headingMatch.groups?.version1 ?? '';
  const headingText = headingMatch.groups?.heading_text.trim() ?? '';

  const isPatchUpdate = (
    /^[0-9]+\.[0-9]+\.[1-9]/.test(releaseVersion)
    || (headingMatch.groups?.heading_level.length ?? 0) >= 3
  );
  const smallerStyleTag = {
    open: '<span style="font-size:smaller">',
    close: '</span>',
  };
  const newHeadingLine = isPatchUpdate
    ? `## ${smallerStyleTag.open}${
      headingText.startsWith(smallerStyleTag.open) && headingText.endsWith(smallerStyleTag.close)
        ? headingText.substring(smallerStyleTag.open.length, headingText.length - smallerStyleTag.close.length)
        : headingText
    }${smallerStyleTag.close}`
    : `## ${headingText}`;
  const trimmedSectionBody = sectionBody.trim();
  const body = trimmedSectionBody === ''
    ? ''
    : `\n${sectionBody.trim()}`;
  return {
    str: `\n\n\n${newHeadingLine}\n${body}`,
    ...sectionRange,
  };
}

/**
 * @param {string} packageRootPath
 * @return {Promise<string | null>}
 */
async function fixChangelog(packageRootPath) {
  const { changelogPath, changelogText } = await fsAsync.readFile(packageRootPath, 'utf8')
    .then(changelogText => ({ changelogPath: packageRootPath, changelogText }))
    .catch(async error => {
      if (error.code !== 'EISDIR') throw error;

      const changelogPath = path.resolve(packageRootPath, 'CHANGELOG.md');
      const changelogText = await fsAsync.readFile(changelogPath, 'utf8');
      return { changelogPath, changelogText };
    });

  const newChangelogText = replaceMulti(
    changelogText,
    await Promise.all(
      [...changelogText.matchAll(VERSION_HEADING_REGEXP)]
        .map((headingMatch, index, headingList) => {
          const nextHeadingMatch = headingList[index + 1];
          return fixChangelogSection(headingMatch, {
            start: (headingMatch.index ?? 0),
            end: nextHeadingMatch?.index ?? Infinity,
          });
        }),
    ),
  );

  if (newChangelogText === changelogText) return null;
  await fsAsync.writeFile(changelogPath, newChangelogText);
  return changelogPath;
}

awaitMainFn(async () => {
  const cwd = process.cwd();
  const [, , ...packageRootPathList] = process.argv;

  if (packageRootPathList.length < 1) throw new Error('Target dirs are not specified.');
  const packageRootFullpathList = packageRootPathList
    .map(packageRootPath => path.resolve(cwd, packageRootPath));

  const errorList = (await Promise.allSettled(packageRootFullpathList.map(fixChangelog)))
    .flatMap((result, index) => {
      if (result.status === 'fulfilled') {
        if (typeof result.value === 'string') {
          console.log(`updated '${path.relative(cwd, result.value)}'`);
        }
        return [];
      }
      return [{
        packageRootPath: packageRootFullpathList[index],
        error: result.reason,
      }];
    });

  if (errorList.length >= 1) {
    throw errorList
      .map(({ packageRootPath, error }) =>
        `fixing '${path.relative(cwd, packageRootPath)}'\n` + inspect(error, process.stderr).replace(/^(?!$)/gm, '  ')
      )
      .join('\n\n');
  }
});
