// automatically generated by the FlatBuffers compiler, do not modify
// @ts-nocheck

import { flatbuffers } from "flatbuffers"
/**
 * @enum {number}
 */
export enum Argon2Type{
  Argon2d= 0,
  Argon2id= 1
};

/**
 * @enum {number}
 */
export enum CryptAlgorithm{
  AES_256_GCM= 0,
  ChaCha20_Poly1305= 1
};

/**
 * @enum {number}
 */
export enum CompressAlgorithm{
  None= 0,
  Gzip= 1,
  Brotli= 2
};

/**
 * @enum {number}
 */
export enum KeyOptions{
  NONE= 0,
  Argon2Options= 1
};

/**
 * @constructor
 */
export class Argon2Options {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Argon2Options
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Argon2Options {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Argon2Options= obj
 * @returns Argon2Options
 */
static getRootAsArgon2Options(bb:flatbuffers.ByteBuffer, obj?:Argon2Options):Argon2Options {
  return (obj || new Argon2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Argon2Options= obj
 * @returns Argon2Options
 */
static getSizePrefixedRootAsArgon2Options(bb:flatbuffers.ByteBuffer, obj?:Argon2Options):Argon2Options {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Argon2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns Argon2Type
 */
type():Argon2Type {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : Argon2Type.Argon2d;
};

/**
 * @returns number
 */
timeIterations():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
};

/**
 * @returns number
 */
memoryKib():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
};

/**
 * @returns number
 */
parallelism():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startArgon2Options(builder:flatbuffers.Builder) {
  builder.startObject(4);
};

/**
 * @param flatbuffers.Builder builder
 * @param Argon2Type type
 */
static addType(builder:flatbuffers.Builder, type:Argon2Type) {
  builder.addFieldInt8(0, type, Argon2Type.Argon2d);
};

/**
 * @param flatbuffers.Builder builder
 * @param number timeIterations
 */
static addTimeIterations(builder:flatbuffers.Builder, timeIterations:number) {
  builder.addFieldInt32(1, timeIterations, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number memoryKib
 */
static addMemoryKib(builder:flatbuffers.Builder, memoryKib:number) {
  builder.addFieldInt32(2, memoryKib, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number parallelism
 */
static addParallelism(builder:flatbuffers.Builder, parallelism:number) {
  builder.addFieldInt32(3, parallelism, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endArgon2Options(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createArgon2Options(builder:flatbuffers.Builder, type:Argon2Type, timeIterations:number, memoryKib:number, parallelism:number):flatbuffers.Offset {
  Argon2Options.startArgon2Options(builder);
  Argon2Options.addType(builder, type);
  Argon2Options.addTimeIterations(builder, timeIterations);
  Argon2Options.addMemoryKib(builder, memoryKib);
  Argon2Options.addParallelism(builder, parallelism);
  return Argon2Options.endArgon2Options(builder);
}
}
/**
 * @constructor
 */
export class Header {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Header
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Header {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Header= obj
 * @returns Header
 */
static getRootAsHeader(bb:flatbuffers.ByteBuffer, obj?:Header):Header {
  return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Header= obj
 * @returns Header
 */
static getSizePrefixedRootAsHeader(bb:flatbuffers.ByteBuffer, obj?:Header):Header {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns CryptAlgorithm
 */
cryptAlgorithm():CryptAlgorithm {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : CryptAlgorithm.AES_256_GCM;
};

/**
 * @param number index
 * @returns number
 */
keySalt(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
};

/**
 * @returns number
 */
keySaltLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Uint8Array
 */
keySaltArray():Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @returns number
 */
keyLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
};

/**
 * @returns KeyOptions
 */
keyOptionsType():KeyOptions {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : KeyOptions.NONE;
};

/**
 * @param flatbuffers.Table obj
 * @returns ?flatbuffers.Table
 */
keyOptions<T extends flatbuffers.Table>(obj:T):T|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
};

/**
 * @param number index
 * @returns number
 */
cryptNonce(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
};

/**
 * @returns number
 */
cryptNonceLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Uint8Array
 */
cryptNonceArray():Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
cryptAuthTag(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
};

/**
 * @returns number
 */
cryptAuthTagLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Uint8Array
 */
cryptAuthTagArray():Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @returns CompressAlgorithm
 */
compressAlgorithm():CompressAlgorithm {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : CompressAlgorithm.None;
};

/**
 * @param flatbuffers.Builder builder
 */
static startHeader(builder:flatbuffers.Builder) {
  builder.startObject(8);
};

/**
 * @param flatbuffers.Builder builder
 * @param CryptAlgorithm cryptAlgorithm
 */
static addCryptAlgorithm(builder:flatbuffers.Builder, cryptAlgorithm:CryptAlgorithm) {
  builder.addFieldInt8(0, cryptAlgorithm, CryptAlgorithm.AES_256_GCM);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset keySaltOffset
 */
static addKeySalt(builder:flatbuffers.Builder, keySaltOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, keySaltOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createKeySaltVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startKeySaltVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param number keyLength
 */
static addKeyLength(builder:flatbuffers.Builder, keyLength:number) {
  builder.addFieldInt16(2, keyLength, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param KeyOptions keyOptionsType
 */
static addKeyOptionsType(builder:flatbuffers.Builder, keyOptionsType:KeyOptions) {
  builder.addFieldInt8(3, keyOptionsType, KeyOptions.NONE);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset keyOptionsOffset
 */
static addKeyOptions(builder:flatbuffers.Builder, keyOptionsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, keyOptionsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset cryptNonceOffset
 */
static addCryptNonce(builder:flatbuffers.Builder, cryptNonceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, cryptNonceOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createCryptNonceVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startCryptNonceVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset cryptAuthTagOffset
 */
static addCryptAuthTag(builder:flatbuffers.Builder, cryptAuthTagOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, cryptAuthTagOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createCryptAuthTagVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startCryptAuthTagVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param CompressAlgorithm compressAlgorithm
 */
static addCompressAlgorithm(builder:flatbuffers.Builder, compressAlgorithm:CompressAlgorithm) {
  builder.addFieldInt8(7, compressAlgorithm, CompressAlgorithm.None);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  builder.requiredField(offset, 6); // key_salt
  builder.requiredField(offset, 12); // key_options
  builder.requiredField(offset, 14); // crypt_nonce
  builder.requiredField(offset, 16); // crypt_auth_tag
  return offset;
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset offset
 */
static finishHeaderBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset offset
 */
static finishSizePrefixedHeaderBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, undefined, true);
};

static createHeader(builder:flatbuffers.Builder, cryptAlgorithm:CryptAlgorithm, keySaltOffset:flatbuffers.Offset, keyLength:number, keyOptionsType:KeyOptions, keyOptionsOffset:flatbuffers.Offset, cryptNonceOffset:flatbuffers.Offset, cryptAuthTagOffset:flatbuffers.Offset, compressAlgorithm:CompressAlgorithm):flatbuffers.Offset {
  Header.startHeader(builder);
  Header.addCryptAlgorithm(builder, cryptAlgorithm);
  Header.addKeySalt(builder, keySaltOffset);
  Header.addKeyLength(builder, keyLength);
  Header.addKeyOptionsType(builder, keyOptionsType);
  Header.addKeyOptions(builder, keyOptionsOffset);
  Header.addCryptNonce(builder, cryptNonceOffset);
  Header.addCryptAuthTag(builder, cryptAuthTagOffset);
  Header.addCompressAlgorithm(builder, compressAlgorithm);
  return Header.endHeader(builder);
}
}
